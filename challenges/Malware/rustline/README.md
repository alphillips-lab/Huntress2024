# Rustline

## Description

<small>Author: @HuskyHacks</small><br><br>Jerry: A Redline Stealer. <br> George: Written in Rust. <br> Jerry: A Rusty Redline Stealer. <br> George: A Rusty Redline Stealer, Jerry! <br><br> We caught a Redline variant executing on an endpoint and intercepted the encrypted files as they traversed the edge proxy. Well, everything except for the flag.txt file (imagine that...). Any chance you could figure out how this thing works and recover the flag? <b>NOTE: Archive password is <code>rustline</code></b> <br><br> <b>Download the file(s) below.</b><br>


## Files

* [challenge.zip](<files/challenge.zip>)

## Solution

This is a "reverse engineering" challenge in the sense that a binary has been provided... not much more :D

Looking through the provided files, you can observe that all of the encrypted private key files start with the same bytes. This is indicative of key re-use on a stream cipher, likely just a hardcoded XOR key.

With normal XOR, and RC4 to an extent, if you have an encrypted file and the plaintext version, you can get the key stream that the algorithm generated up to the size of the file you have the plaintext of simply by XORing the plaintext and ciphertext.

P $\oplus$ C == `keystream[:len(P)]`

We can get the flag by getting the key stream, then XORing the flag file with the key stream. In this case, however, after XORing the plaintext and ciphertext you will notice a repeating XOR key that is quite small. Using this key on the flag file yields the flag:

```
emit flag.txt |r.xor h:B8F72FF695587745B08FDC8EE71ADF7E |r.rex "flag.*\n"
```