# That's Life

## Description

<small>Author: @HuskyHacks</small><br><br>Put on some lofi beats, run this game, stare at the terminal, and let life start to make sense. Don't think too hard about the solution, it's in there somewhere.
<br><br> <b>Press the <code>Start</code> button on the top-right to begin this challenge.</b>


## Solution

This challenge required you to upload a game file to a server to receive the flag. The service provided a download for an (alleged, I'm only going off the name) implementation of Conway's Game of Life, written in Go (the file is in the files folder here).

The game implements a save/load feature where each round's game state is serialized and saved to the file `game_state.pb`. The method of serialization is protobuf, which is a messaging protocol meant for serializing arbitrary datastructures.

Reading the code, we can see there is a function that initializes a winning gamestate, and then the current game state is checked against values in the winning game state.

The winning game state is a series of 12 coordinate locations that must have a specific color associated with them.

Fortunately, IDA was able to parse the types provided in the `pclntab` (if this doesn't work in other decompilers, check out the tool GoReSym), so attached is a screenshot of the main logic after applying some clean-up with types in the decompiler:

![life_1.png](/images/life_1.png)

It's not super clean still, it could use some more work, but notice how there are 4 checks against values in the win condition, and you can imagine that these checks are against the current game state based on the available information.

The last three checks in order:
* Check x coordinate == win condition coordinate
* Check y coordinate == win condition coordinate
* Check the color for the item at the location is the same as the win condition

The win condition state is pretty easy to find as well in the data section. Setting it to the correct type will get you everything you need:

![life_2.png](/images/life_2.png)

I originally got the win condition state by debugging it. There is a GDB script to do so in the _Appendix_.

We can then apply the win condition state to a game state by parsing the gamestate with the protobuf library, modifying it, then saving a new copy.

The main script used for modification, the protobuf file generated by `protoc` and the `.proto` specification for this file are all in the _Appendix_.

## References

Here were some helpful tools as well for trying to dump the protobuf specification from the binary:

https://github.com/arkadiyt/protodump

https://github.com/Accenture/protobuf-finder/blob/master/protobuf-finder.py


Link to GoReSym for applying symbols stored in the `pclntab`

https://github.com/mandiant/GoReSym

GDB Plugin for python:

https://sourceware.org/gdb/current/onlinedocs/gdb.html/Python-API.html#Python-API


## White's Solution

Here is also a funny solution, courtesy of White. The patched file is in the files folder.

![life_white.png](/images/life_white.png)

## Appendix

GDB Script for parsing the win condition state:
```python
import gdb
import struct
import json

ge = gdb.execute
parse = gdb.parse_and_eval

bps = [
    0x564277, # After win condition is initialized
]

for bp in bps:
    ge(f"b*{hex(bp)}")

ge("r")
win_cond_arr = 0x7154B0
win_conditions = []
try:
    print("Parsing win condition array")
    ge(f"x/36x *(void**){hex(win_cond_arr)}")
    ptr = gdb.inferiors()[0].read_memory(win_cond_arr, 8)
    for i in range(12):
        data = gdb.inferiors()[0].read_memory(int.from_bytes(ptr, "little")+(i*8*4), 4*8)
        print(bytes(data))
        data = struct.unpack("QQQQ", data)
        win_conditions.append(
            {
                "x": data[0],
                "y": data[1],
                "color": data[2],
                "matched": data[3]
            }
        )
except Exception as e:
    print("Error in script:", e)


print(json.dumps(win_conditions, indent=4))
```

Python file for modifying the game state with the win condition:
```python

import json
import sys
from google.protobuf.json_format import ParseDict, MessageToJson
import protofile_pb2  # Replace with your actual protobuf module

# Assuming you have a JSON string
with open(sys.argv[1], "rb") as f:
    data = protofile_pb2.Grid()
    data.ParseFromString(f.read())

data = json.loads(MessageToJson(data))

data["rows"][10]["cells"][15] = {"alive": True, "color": 31 }
data["rows"][20]["cells"][25] = {"alive": True, "color": 32 }
data["rows"][30]["cells"][35] = {"alive": True, "color": 33 }
data["rows"][40]["cells"][45] = {"alive": True, "color": 34 }
data["rows"][25]["cells"][50] = {"alive": True, "color": 35 }
data["rows"][5]["cells"][55] = {"alive": True, "color": 36 }
data["rows"][15]["cells"][60] = {"alive": True, "color": 37 }
data["rows"][35]["cells"][65] = {"alive": True, "color": 31 }
data["rows"][45]["cells"][70] = {"alive": True, "color": 32 }
data["rows"][0]["cells"][75] = {"alive": True, "color": 33 }
data["rows"][1]["cells"][80] = {"alive": True, "color": 34 }
data["rows"][2]["cells"][85] = {"alive": True, "color": 35 }

# Parse the JSON string into a protobuf message
message = ParseDict(data, protofile_pb2.Grid())

# Serialize the protobuf message to binary format
binary_data = message.SerializeToString()

with open('game_state.pb', 'wb') as f:
    f.write(binary_data)
```

Protobuf specification required to deserialize the game state:
```
syntax = "proto3";

package thats_life;

message Cell {
 bool alive = 1;
 int32 color = 2;
}

message CellRow {
 repeated Cell cells = 1;
}

message Grid {
 int32 width = 1;
 int32 height = 2;
 repeated CellRow rows = 3;
}
```

Python protofile generated by `protoc`
```python
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: protofile.proto
# Protobuf Python Version: 5.28.3
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    5,
    28,
    3,
    '',
    'protofile.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x0fprotofile.proto\x12\nthats_life\"$\n\x04\x43\x65ll\x12\r\n\x05\x61live\x18\x01 \x01(\x08\x12\r\n\x05\x63olor\x18\x02 \x01(\x05\"*\n\x07\x43\x65llRow\x12\x1f\n\x05\x63\x65lls\x18\x01 \x03(\x0b\x32\x10.thats_life.Cell\"H\n\x04Grid\x12\r\n\x05width\x18\x01 \x01(\x05\x12\x0e\n\x06height\x18\x02 \x01(\x05\x12!\n\x04rows\x18\x03 \x03(\x0b\x32\x13.thats_life.CellRowb\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'protofile_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  DESCRIPTOR._loaded_options = None
  _globals['_CELL']._serialized_start=31
  _globals['_CELL']._serialized_end=67
  _globals['_CELLROW']._serialized_start=69
  _globals['_CELLROW']._serialized_end=111
  _globals['_GRID']._serialized_start=113
  _globals['_GRID']._serialized_end=185
# @@protoc_insertion_point(module_scope)
```
